var documenterSearchIndex = {"docs":
[{"location":"#Introduction","page":"FITS","title":"Introduction","text":"","category":"section"},{"location":"","page":"FITS","title":"FITS","text":"FITS.jl is a Julia implementation of the Flexible Image Transport System (FITS) file IO standard.","category":"page"},{"location":"#FITS.fits-Tuple{IO}","page":"FITS","title":"FITS.fits","text":"fits(io::IO; <keywords>)\nfits(filename::AbstractString; <keywords>)\n\nOpen and read a FITS file, returning a vector of header-data units (HDUs).\n\nThe default data stucture for Random and Bintable HDUs is a named tuple of arrays.\n\nKeywords\n\nrecord::Bool=false: structure the data as a list of records\nscale::Bool=true: apply the scale and zero keywords to the data\n\n\n\n\n\n","category":"method"},{"location":"#FITS.info-Tuple{Vector{HDU}}","page":"FITS","title":"FITS.info","text":"info(hdus::Vector{HDU})\n\nBriefly describe the list of header-data units (HDUs).\n\n\n\n\n\n","category":"method"},{"location":"#FITS.write-Tuple{IO, Vector{HDU}}","page":"FITS","title":"FITS.write","text":"write(io::IO, hdus::Vector{HDU})    write(filename::AbstractString, hdus::Vector{HDU})\n\nWrite a vector of header-data units (HDUs) to a file.\n\n\n\n\n\n","category":"method"},{"location":"#FITS.Bintable","page":"FITS","title":"FITS.Bintable","text":"Bintable header-data unit (HDU)\n\nA Bintable HDU consists of a vector of cards and optionally a 2-dimensional array of binary data structured as a vector of records.\n\n\n\n\n\n","category":"type"},{"location":"#FITS.DataFormat","page":"FITS","title":"FITS.DataFormat","text":"DataFormat(type, leng, shape, param, group, heap)\n\nThe generic data format descriptor for HDUs.\n\n\n\n\n\n","category":"type"},{"location":"#FITS.HDU","page":"FITS","title":"FITS.HDU","text":"HDU{T}(cards, data)\nHDU([data, [cards]]; <keywords>)\nHDU(cards; <keywords>)\nHDU(type, nothing, [cards]; <keywords>)\nHDU(type, data, [cards]; <keywords>)\n\nCreate an header-data unit described by data and cards of type AbstractHDU.\n\nThe HDU function tries to determine the HDU type based on the data and cards. If only data is provided, then an array is interpreted as a Primary HDU and a Tuple or NamedTuple as a BinaryTable. If mandatory cards are provided, then they are used to determine the HDU type. Otherwise, the HDU type must be specified.\n\nHDU types are: Primary, Random, Image, Table, Bintable, and Conform.\n\narguments\n\ndata::U=nothing: the binary or ASCII data, where U<:Union{AbstractArray,   Tuple, NamedTuple, Nothing}\ncards::U=nothing: the list of cards, where U<:Union{Card, Vector{Card}, Nothing}\n\nKeywords\n\nrecord::Bool=false: structure the data as a list of records\nscale::Bool=true: apply the scale and zero keywords to the data\nappend::Bool=false: append CONTINUE cards for long strings (>68 characters)\nfixed::Bool=true: create fixed format cards\nslash::Integer=32: character index of the comment separator (/)\nlpad::Integer=1: number of spaces before the comment separator\nrpad::Integer=1: number of spaces after the comment separator\ntruncate::Bool=true: truncate the comment string at the end of the card\n\n\n\n\n\n","category":"type"},{"location":"#FITS.Image","page":"FITS","title":"FITS.Image","text":"Image header-data unit (HDU)\n\nAn Image HDU consists of a vector cards and optionally a multidimensional array (<=999 dimensions).\n\n\n\n\n\n","category":"type"},{"location":"#FITS.Primary","page":"FITS","title":"FITS.Primary","text":"Primary header-data unit (HDU)\n\nA Primary HDU consists of a vector of cards and optionally a multidimensional array (<=999 dimensions). The Primary HDU is the first HDU in a vector of HDUs.\n\n\n\n\n\n","category":"type"},{"location":"#FITS.Random","page":"FITS","title":"FITS.Random","text":"Random header-data unit (HDU)\n\nA Random HDU consists of a vector of cards and optionally a vector of records containing a list of parameters followed by a multidimensional array. The Random HDU is the first HDU in a vector of HDUs.\n\n\n\n\n\n","category":"type"},{"location":"#FITS.Table","page":"FITS","title":"FITS.Table","text":"Table header-data unit (HDU)\n\nA Table HDU consists of a vector of cards and optionally a 2-dimensional array of ASCII data structured as vector of records.\n\n\n\n\n\n","category":"type"},{"location":"#FITS.info-Tuple{HDU}","page":"FITS","title":"FITS.info","text":"info(hdu::HDU)\n\nBriefly describe the header-data unit.\n\n\n\n\n\n","category":"method"},{"location":"#FITS.read-Tuple{IO, Type{HDU}}","page":"FITS","title":"FITS.read","text":"read(io, type; <keywords>)\n\nRead the specified HDU type from a file.\n\n\n\n\n\n","category":"method"},{"location":"#FITS.typeofhdu-Tuple{U} where U<:Union{Nothing, Tuple, AbstractArray, NamedTuple}","page":"FITS","title":"FITS.typeofhdu","text":"typeofhdu(data)\ntypeofhdu(dict)\ntypeofhdu(data, dict)\n\nDetermine the HDU type based on the data structure, the mandatory keywords, or both.\n\n\n\n\n\n","category":"method"},{"location":"#FITS.write-Tuple{IO, HDU}","page":"FITS","title":"FITS.write","text":"write(io, hdu; <keywords>)\n\nWrite the specified HDU type to a file.\n\n\n\n\n\n","category":"method"},{"location":"#FITS.Card","page":"FITS","title":"FITS.Card","text":"Card(type, key, value, comment, format)\nCard([key, [value, [comment]]]; <keywords>)\nCard(\"HIERARCH\", key, [key, [value, [comment]]]; <keywords>)\n\nCreate a card type, where type is Comment, End, Hierarch, History, Invalid, or Value{T}.\n\nArgments\n\nkey::AbstractString=\"\": keyword string\nvalue::U=missing: keyword value, where U is Bool, Number, or String\ncomment::AbstractString=\"\": comment string\n\nKeywords\n\nappend::Bool=false: append CONTINUE cards for long strings (>68 characters)\nfixed::Bool=true: use fixed format\nslash::Integer=32: index of comment separator (/)\nlpad::Integer=1: number of spaces before comment separator\nrpad::Integer=1: number of spaces after comment separator\ntruncate::Bool=true: truncate comment at end of card\n\n\n\n\n\n","category":"type"},{"location":"#FITS.CardFormat","page":"FITS","title":"FITS.CardFormat","text":"CardFormat(fixd, vbeg, vend, ampr, slsh, cbeg, cend)\n\nCreate a card format descriptor.\n\n\n\n\n\n","category":"type"},{"location":"#FITS.join_cards-Tuple{AbstractArray{Card}}","page":"FITS","title":"FITS.join_cards","text":"join_cards(cards)\n\nJoin CONTINUE cards to initial long string card to create a long value and comment card\n\n\n\n\n\n","category":"method"},{"location":"#FITS.parse-Tuple{Type{Card}, AbstractString}","page":"FITS","title":"FITS.parse","text":"parse(Card, image)\n\nParse 80 character card image from string buffer.\n\n\n\n\n\n","category":"method"},{"location":"#FITS.split_card-Union{Tuple{C}, Tuple{S}, Tuple{K}, Tuple{K, S, C, Any}} where {K<:AbstractString, S<:AbstractString, C<:AbstractString}","page":"FITS","title":"FITS.split_card","text":"split_card(key, value, comment, format)\n\nSplit card having long value and comment fields into multiple cards\n\nIf length of comment field is 0 because comment separator index is too large, then comment is deleted.  Decreasing comment separator index will allow inclusion of comment.\n\n\n\n\n\n","category":"method"}]
}
